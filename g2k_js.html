<!DOCTYPE html>
<html>
<head>
<title>g2k_js.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
	/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
	/*---------------------------------------------------------------------------------------------
	 *  Copyright (c) Microsoft Corporation. All rights reserved.
	 *  Licensed under the MIT License. See License.txt in the project root for license information.
	 *--------------------------------------------------------------------------------------------*/
	
	body {
		font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
		font-size: var(--vscode-markdown-font-size, 14px);
		padding: 0 26px;
		line-height: var(--vscode-markdown-line-height, 22px);
		word-wrap: break-word;
		background-color: rgb(47, 47, 47);
		color: rgb(215, 215, 215);
	}
	
	#code-csp-warning {
		position: fixed;
		top: 0;
		right: 0;
		color: white;
		margin: 16px;
		text-align: center;
		font-size: 12px;
		font-family: sans-serif;
		background-color:#444444;
		cursor: pointer;
		padding: 6px;
		box-shadow: 1px 1px 1px rgba(0,0,0,.25);
	}
	
	#code-csp-warning:hover {
		text-decoration: none;
		background-color:#007acc;
		box-shadow: 2px 2px 2px rgba(0,0,0,.25);
	}
	
	body.scrollBeyondLastLine {
		margin-bottom: calc(100vh - 22px);
	}
	
	body.showEditorSelection .code-line {
		position: relative;
	}
	
	body.showEditorSelection .code-active-line:before,
	body.showEditorSelection .code-line:hover:before {
		content: "";
		display: block;
		position: absolute;
		top: 0;
		left: -12px;
		height: 100%;
	}
	
	body.showEditorSelection li.code-active-line:before,
	body.showEditorSelection li.code-line:hover:before {
		left: -30px;
	}
	
	.vscode-light.showEditorSelection .code-active-line:before {
		border-left: 3px solid rgba(0, 0, 0, 0.15);
	}
	
	.vscode-light.showEditorSelection .code-line:hover:before {
		border-left: 3px solid rgba(0, 0, 0, 0.40);
	}
	
	.vscode-light.showEditorSelection .code-line .code-line:hover:before {
		border-left: none;
	}
	
	.vscode-dark.showEditorSelection .code-active-line:before {
		border-left: 3px solid rgba(255, 255, 255, 0.4);
	}
	
	.vscode-dark.showEditorSelection .code-line:hover:before {
		border-left: 3px solid rgba(255, 255, 255, 0.60);
	}
	
	.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
		border-left: none;
	}
	
	.vscode-high-contrast.showEditorSelection .code-active-line:before {
		border-left: 3px solid rgba(255, 160, 0, 0.7);
	}
	
	.vscode-high-contrast.showEditorSelection .code-line:hover:before {
		border-left: 3px solid rgba(255, 160, 0, 1);
	}
	
	.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
		border-left: none;
	}
	
	img {
		max-width: 100%;
		max-height: 100%;
	}
	
	a {
		text-decoration: none;
		color: rgb(133, 133, 255);
	}
	
	a:hover {
		text-decoration: underline;
	}
	
	a:focus,
	input:focus,
	select:focus,
	textarea:focus {
		outline: 1px solid -webkit-focus-ring-color;
		outline-offset: -1px;
	}
	
	hr {
		border: 0;
		height: 2px;
		border-bottom: 2px solid;
	}
	
	h1 {
		padding-bottom: 0.3em;
		line-height: 1.2;
		border-bottom-width: 1px;
		border-bottom-style: solid;
		border-color: rgb(106, 106, 106);
	}
	
	h1, h2, h3 {
		font-weight: normal;
	}
	
	table {
		border-collapse: collapse;
	}
	
	table > thead > tr > th {
		text-align: left;
		border-bottom: 1px solid;
	}
	
	table > thead > tr > th,
	table > thead > tr > td,
	table > tbody > tr > th,
	table > tbody > tr > td {
		padding: 5px 10px;
	}
	
	table > tbody > tr + tr > td {
		border-top: 1px solid;
	}
	
	blockquote {
		margin: 0 7px 0 5px;
		padding: 0 16px 0 10px;
		border-left-width: 5px;
		border-left-style: solid;
	}
	
	code {
		font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
		font-size: 1em;
		line-height: 1.357em;
	}
	
	body.wordWrap pre {
		white-space: pre-wrap;
	}
	
	pre:not(.hljs),
	pre.hljs code > div {
		padding: 16px;
		border-radius: 3px;
		overflow: auto;
	}
	
	pre code {
		color: var(--vscode-editor-foreground);
		tab-size: 4;
	}
	
	/** Theming */
	
	.vscode-light pre {
		background-color: rgba(220, 220, 220, 0.4);
	}
	
	.vscode-dark pre {
		background-color: rgba(10, 10, 10, 0.4);
	}
	
	.vscode-high-contrast pre {
		background-color: rgb(0, 0, 0);
	}
	
	.vscode-high-contrast h1 {
		border-color: rgb(0, 0, 0);
	}
	
	.vscode-light table > thead > tr > th {
		border-color: rgba(0, 0, 0, 0.69);
	}
	
	.vscode-dark table > thead > tr > th {
		border-color: rgba(255, 255, 255, 0.69);
	}
	
	.vscode-light h1,
	.vscode-light hr,
	.vscode-light table > tbody > tr + tr > td {
		border-color: rgba(0, 0, 0, 0.18);
	}
	
	.vscode-dark h1,
	.vscode-dark hr,
	.vscode-dark table > tbody > tr + tr > td {
		border-color: rgba(255, 255, 255, 0.18);
	}
	
	</style>
	
	<style>
	/* Tomorrow Theme */
	/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
	/* Original theme - https://github.com/chriskempson/tomorrow-theme */
	
	/* Tomorrow Comment */
	.hljs-comment,
	.hljs-quote {
		color: #8e908c;
	}
	
	/* Tomorrow Red */
	.hljs-variable,
	.hljs-template-variable,
	.hljs-tag,
	.hljs-name,
	.hljs-selector-id,
	.hljs-selector-class,
	.hljs-regexp,
	.hljs-deletion {
		color: #c82829;
	}
	
	/* Tomorrow Orange */
	.hljs-number,
	.hljs-built_in,
	.hljs-builtin-name,
	.hljs-literal,
	.hljs-type,
	.hljs-params,
	.hljs-meta,
	.hljs-link {
		color: #f5871f;
	}
	
	/* Tomorrow Yellow */
	.hljs-attribute {
		color: #eab700;
	}
	
	/* Tomorrow Green */
	.hljs-string,
	.hljs-symbol,
	.hljs-bullet,
	.hljs-addition {
		color: #718c00;
	}
	
	/* Tomorrow Blue */
	.hljs-title,
	.hljs-section {
		color: #4271ae;
	}
	
	/* Tomorrow Purple */
	.hljs-keyword,
	.hljs-selector-tag {
		color: #8959a8;
	}
	
	.hljs {
		display: block;
		overflow-x: auto;
		color: #c6c6c6;
		padding: 0.5em;
	}
	
	.hljs-emphasis {
		font-style: italic;
	}
	
	.hljs-strong {
		font-weight: bold;
	}
	</style>
	
	<style>
	/*
	 * Markdown PDF CSS
	 */
	
	 body {
		font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
		padding: 0 12px;
	}
	
	pre {
		background-color: #222222;
		border: 1px solid #000000;
		border-radius: 3px;
		overflow-x: auto;
		white-space: pre-wrap;
		overflow-wrap: break-word;
	}
	
	pre:not(.hljs) {
		padding: 23px;
		line-height: 19px;
	}
	
	blockquote {
		background: rgba(127, 127, 127, 0.1);
		border-color: rgba(0, 122, 204, 0.5);
	}
	
	.emoji {
		height: 1.4em;
	}
	
	code {
		font-size: 14px;
		line-height: 19px;
	}
	
	/* for inline code */
	:not(pre):not(.hljs) > code {
		color: #C9AE75; /* Change the old color so it seems less like an error */
		font-size: inherit;
	}
	
	/* Page Break : use <div class="page"/> to insert page break
	-------------------------------------------------------- */
	.page {
		page-break-after: always;
	}
	
	</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="javascript">JavaScript</h1>
<p>Oh boi, this is where the fun begins. Az erre való Bibliát megtalálod <a href="https://www.w3schools.com/js/">ezen a linken</a>.</p>
<h2 id="hogyan-haszn%C3%A1ljunk-javascriptet">Hogyan használjunk JavaScriptet?</h2>
<p>Baromi sokféleképpen lehet, most megmutatom azt a fajtát amire nekünk szükségünk lesz. Szórakozásból és tesztelésképpen irogathatunk JS kódot a böngészőnk console-jában is. HTML-be kétféleképpen rakhatunk JS kódot, az egyik, hogy a <code>&lt;body&gt;</code> után egy:</p>
<p><code>&lt;script src=&quot;scripts/myscript.js&quot;&gt;&lt;/script&gt;</code></p>
<p>tag-el behúzzuk a &quot;scripts&quot; mappából a myscript.js fájlunkat.</p>
<p>A másik pedig hogy közvetlen a <code>&lt;script&gt;</code> tagbe írunk JS kódot:</p>
<pre class="hljs"><code><div>&lt;script&gt;
    var myname = &quot;Earl&quot;;
    console.log(&quot;My name is &quot;+myname);
&lt;/script&gt;
</div></code></pre>
<p>De lehetőleg maradjunk annál hogy külön fájlba írjuk a kódjainkat.</p>
<h2 id="v%C3%A1ltoz%C3%B3k">Változók</h2>
<p>Kezdjük az alapokkal.</p>
<p><strong>Mi is az a változó?</strong> Minden programozási nyelvben vannak változók. Változóknak nevezzük azt, amiben valamilyen értéket vagy adatok tárolunk, legyen az szöveg, vagy szám stb. Háromféleképpen lehet változót létrehozni:</p>
<pre class="hljs"><code><div>const sex = &quot;Male&quot;;
var name = &quot;Margit&quot;;
let age = 69;
</div></code></pre>
<p>Először koncentráljunk a <code>var</code>-al való létrehozásra. A <code>var</code> (mint variable) kulcsszóval hozunk létreváltozót, ezután megadjuk a nevét, majd egyenlőség jel után pedig megadjuk az értékét, utána ;-vel lezárjuk.</p>
<h2 id="hogyan-nevezz%C3%BCk-el-a-v%C3%A1ltoz%C3%B3kat">Hogyan nevezzük el a változókat?</h2>
<p>Van rá egy jó kis leírás:</p>
<ul>
<li>A JavaScript változók tartalmazhatnak betűket, számokat, alsó vonást (_) és $ jelet.</li>
<li>MINDIG betűvel kell hogy kezdődjenek</li>
<li>Amúgy kezdődhet _ vagy $ jellel is, de ez nem ajánlott, hányadékul nézni.</li>
<li>Case sensitive-ek a változó nevek, szóval a <code>var y</code> és <code>var Y</code> két különböző változónak számít</li>
</ul>
<h2 id="v%C3%A1ltoz%C3%B3k-l%C3%A9trehoz%C3%A1sa">Változók létrehozása</h2>
<p>JavaScript-ben a változóknak nincs fix adattipusok, szóval nem kell úgy megadni egy szám változók mint pl c#-ban hogy <code>int age = 2;</code>...</p>
<p>Itt elég `var age = 2;&quot;-vel létrehozni egy szám változót, mert az egyenlőségjel után megadott érték fogja eldönteni a tipusát.</p>
<pre class="hljs"><code><div>var age = 2;
var name = &quot;Bela&quot;;
</div></code></pre>
<p>Számot úgy rakunk változóba, hogy csak simán leírjuk a számot, ha pedig szöveget szeretnénk belerakni, akkor az macskakörömmel tegyük, mint ahogy a fenti példában is látható.</p>
<h2 id="mi-az-a-%22let%22">Mi az a &quot;let&quot;?</h2>
<p>A &quot;let&quot; abban különbözik a &quot;var&quot;-tól, hogy csak egyszer tudjuk létrehozni ugyan azzal a névvel, és block scopeja van.</p>
<pre class="hljs"><code><div>let x = &quot;John Doe&quot;;

let x = 0;

// SyntaxError: 'x' has already been declared
// Ahogy látjuk itt is, nem tudtunk később véletlen még egy x nevű változót létrehozni mert hibát kapunk
</div></code></pre>
<p>Viszont ha ugyan ezt próbáljuk &quot;let&quot; helyett &quot;var&quot;-al, akkor újra létretudjuk hozni a változót ugyan azzal a névvel, és felülírjuk a tartalmát. Tartalomban és felhasználásban egyébként nem tér el semmiben a &quot;let&quot; és a &quot;var&quot;.</p>
<p>A másik fontos dolog amiben különbözik a &quot;let&quot;, hogy ha egy blokkban létrehozzuk, az csak ott lesz használható, példa:</p>
<pre class="hljs"><code><div>if (true) {
    let x = 2;
}

//az if-en kívül már nem fogjuk tudni elérni a let-et.
//ha &quot;var&quot;-t írnánk a &quot;let&quot; helyett, akkor eltudnánk érni
</div></code></pre>
<h2 id="mi-az-a-%22const%22">Mi az a &quot;const&quot;?</h2>
<p>A &quot;const&quot; nagyon hasonlít a &quot;let&quot;-re, ugyan úgy block scopeja van, ugyan úgy csak egyszer tudjuk létrehozni, de emellé még az is hozzátartozik, hogy ha egyszer létrehozzuk és értéket adunk neki, többször azt később nem tudjuk megváltoztatni! Példa:</p>
<pre class="hljs"><code><div>const PI = 3.141592653589793;
PI = 3.14;      // Hibát fogunk erre kapni ha megakarjuk változtatni a már megadott értékét
</div></code></pre>
<h1 id="oper%C3%A1torok">Operátorok</h1>
<p>Operátorokkal kezeljük a változók értékeit. Sorban vegyük át őket:</p>
<h1 id="%C3%A9rt%C3%A9k-hozz%C3%A1ad%C3%B3-oper%C3%A1torok">Érték hozzáadó operátorok</h1>
<h2 id="%22%22-jel-oper%C3%A1tor">&quot;=&quot; jel operátor</h2>
<p>Sima egyenlőségjel operátorral tudunk adatot megadni egy változónak, példa:</p>
<p><code>var name = &quot;Jani&quot;;</code></p>
<h2 id="%22%22-jel-oper%C3%A1tor">&quot;+&quot; jel operátor</h2>
<p>Plusz jellel adunk össze dolgokat. Példa:</p>
<pre class="hljs"><code><div>var number1 = 5;
var number2 = 3;
var total = number1 + number2; //a total értéke 8 lesz

var text1 = &quot;My name is &quot;;
var text2 = &quot;Earl&quot;;
var total_text = text1 + text2; //&quot;My name is Earl&quot; lesz a total_text értéke.

var everything = &quot;Itt van minden amit létrehoztunk: &quot; + text1 + text2 + number1 + number2;
//&quot;Itt van minden amit létrehoztunk: My name is Earl53&quot; lesz az everything változó tartalma.
//Miért lett 53 a vége és nem 8?
//Azért mert amikor szöveget kezdtünk el rakni a változóba, akkor már nem szám lett a változó tipusa, hanem szöveg, és ha szöveget plusszozunk egymás mellé, akkor azt csak simán egymás mellé rakja. Ha szöveg mellé számot rakunk, akkor azt mellé rakja, mint egy szöveget.
</div></code></pre>
<h2 id="%22-%22-jel-oper%C3%A1tor">&quot;-&quot; jel operátor</h2>
<p>Minusz jellel vonunk ki számokat egymásból.</p>
<pre class="hljs"><code><div>var number1 = 5;
var number2 = 3;
var total = number1 - number2; //a total értéke 2 lesz
</div></code></pre>
<h2 id="%22%22-jel-oper%C3%A1tor">&quot;*&quot; jel operátor</h2>
<p>Csillag jellel szorzunk számokat.</p>
<pre class="hljs"><code><div>var number1 = 5;
var number2 = 3;
var total = number1 * number2; //a total értéke 15 lesz
</div></code></pre>
<h2 id="%22%22-jel-oper%C3%A1tor">&quot;/&quot; jel operátor</h2>
<p>Per jellel osztunk számokat.</p>
<pre class="hljs"><code><div>var number1 = 5;
var number2 = 3;
var total = number1 / number2; //a total értéke 1.6666666666666667 lesz
</div></code></pre>
<h2 id="%22%22-jel-oper%C3%A1tor">&quot;%&quot; jel operátor</h2>
<p>Százalék jellel maradékos osztást tudunk csinálni.</p>
<pre class="hljs"><code><div>var number1 = 5;
var number2 = 3;
var total = number1 % number2; //a total értéke 2 lesz
</div></code></pre>
<h2 id="%C3%A9s----jel-oper%C3%A1tor">++ és -- jel operátor</h2>
<p>++ és -- jelekkel eggyel növelni vagy csökkenteni tudjuk a szám változó értékét.</p>
<pre class="hljs"><code><div>var number1 = 1;
number1++;
console.log(number1); //most már azt fogod látni hogy 2 az értéke
</div></code></pre>
<h1 id="megl%C3%A9v%C5%91-%C3%A9rt%C3%A9k-m%C3%B3dos%C3%ADt%C3%B3-oper%C3%A1torok">Meglévő érték módosító operátorok</h1>
<h2 id="%22%22-oper%C3%A1tor">&quot;+=&quot; operátor</h2>
<p>Ezzel a meglévő értékhez tudunk hozzáadni újabb értéket.</p>
<pre class="hljs"><code><div>var number1 = 1;
number1 += 5;
console.log(number1); //most már azt fogod látni hogy 6 az értéke

var text1 = &quot;Why are you&quot;;
text1 += &quot; geh&quot;;
console.log(text1); //most már azt fogod látni hogy &quot;Why are you geh&quot; a szöveg értéke
</div></code></pre>
<h2 id="%22-%22-oper%C3%A1tor">&quot;-=&quot; operátor</h2>
<p>Ugyan az mint a hozzáadás, csak kivonás.</p>
<pre class="hljs"><code><div>var number1 = 5;
number1 -= 2;
console.log(number1); //most már azt fogod látni hogy 3 az értéke
</div></code></pre>
<h2 id="%22%22-oper%C3%A1tor">&quot;*=&quot; operátor</h2>
<p>Szorozzuk a meglévő értéket.</p>
<pre class="hljs"><code><div>var number1 = 5;
number1 *= 2;
console.log(number1); //most már azt fogod látni hogy 10 az értéke
</div></code></pre>
<h2 id="%22%22-oper%C3%A1tor">&quot;/=&quot; operátor</h2>
<p>Osztjuk a meglévő értéket.</p>
<pre class="hljs"><code><div>var number1 = 5;
number1 /= 2;
console.log(number1); //most már azt fogod látni hogy 2.5 az értéke
</div></code></pre>
<h2 id="%22%22-oper%C3%A1tor">&quot;%=&quot; operátor</h2>
<p>Maradékosan osztjuk a meglévő értéket.</p>
<pre class="hljs"><code><div>var number1 = 5;
number1 %= 2;
console.log(number1); //most már azt fogod látni hogy 1 az értéke
</div></code></pre>
<h1 id="%C3%B6sszehasonl%C3%ADt%C3%B3-oper%C3%A1torok">Összehasonlító operátorok</h1>
<h2 id="%22%22-oper%C3%A1tor">&quot;==&quot; operátor</h2>
<p>Összehasonlító operátor. A két egyenlőségjel egyik és másik végén lévő értéket vagy változót összehasonlítja, és true vagy false értéket fog adni.</p>
<pre class="hljs"><code><div>if (5 == 10) {
    console.log(&quot;igen&quot;);
} else {
    console.log(&quot;nem&quot;);
}

//Mint láthatjuk, 5 nem egyenlő 10-el, így nem fog lefutni az if függvényünk
</div></code></pre>
<h2 id="%22%22-oper%C3%A1tor">&quot;===&quot; operátor</h2>
<p>Ugyan az mint a == operátor, csak itt nem csak az értéket vizsgálja, hanem az adatnak a tipusát is.</p>
<pre class="hljs"><code><div>if (5 == &quot;5&quot;) {
    console.log(&quot;igen két egyenlőségjellel&quot;);
}

if (5 === &quot;5&quot;) {
    console.log(&quot;igen háromegyenlőségjellel&quot;);
}

//Mint láthatjuk, két egyenlőség jellel látjuk a konzolba a feliratot
//Három egyenlőség jellel már nem, mert szám 5-t hasonlítunk össze szöveg 5-el, és mivel itt már eltér az adattipusa, nem teljesül true-ra a vizsgálat
</div></code></pre>
<h2 id="%22%22-oper%C3%A1tor">&quot;!=&quot; operátor</h2>
<p>Nem egyenlő!</p>
<pre class="hljs"><code><div>if (5 != 10) {
    console.log(&quot;yes&quot;);
}

if (&quot;Labda&quot; != &quot;Gömböc&quot;) {
    console.log(&quot;yesyes&quot;);
}

//Látni fogjuk a konzolba hogy kiírta a programunk hogy &quot;yes&quot;, mivel 5 nem egyenlő 10-el, és azt is hogy &quot;yesyes&quot; mivel a két szöveg nem ugyan az.
</div></code></pre>
<h2 id="%22%22-oper%C3%A1tor">&quot;!==&quot; operátor</h2>
<p>Nem egyenlő az érték, vagy nem egyezik a tipus.</p>
<pre class="hljs"><code><div>if (5 !== &quot;10&quot;) {
    console.log(&quot;yes&quot;);
}

//látni fogjuk a konzolba azt hogy &quot;yes&quot;.
</div></code></pre>
<h2 id="%22%22-oper%C3%A1tor">&quot;&gt;&quot; operátor</h2>
<p>Nagyobb mint...</p>
<pre class="hljs"><code><div>if (5 &gt; 2) {
    console.log(&quot;yes&quot;);
}

//látni fogjuk hogy &quot;yes&quot;, mivel 5 nagyobb mint 2
</div></code></pre>
<h2 id="%22%22-oper%C3%A1tor">&quot;&lt;&quot; operátor</h2>
<p>Kissebb mint...</p>
<pre class="hljs"><code><div>if (2 &lt; 5) {
    console.log(&quot;yes&quot;);
}

//látni fogjuk hogy &quot;yes&quot;, mivel 2 kissebb mint 5
</div></code></pre>
<h2 id="%22%22-oper%C3%A1tor">&quot;&gt;=&quot; operátor</h2>
<p>Nagyobb vagy egyenlő...</p>
<pre class="hljs"><code><div>if (5 &gt;= 2) {
    console.log(&quot;yes1&quot;);
}

if (5 &gt;= 5) {
    console.log(&quot;yes2&quot;);
}

if (5 &gt; 5) {
    console.log(&quot;yes3&quot;);
}

//Azt hogy &quot;yes3&quot; már nem fogjuk látni, mivel 5 nem nagyobb 5nél, de felette azt hogy &quot;yes2&quot; látni fogjuk, mert 5 nagyobb VAGY egyenlő 5-el.
</div></code></pre>
<h2 id="%22%22-oper%C3%A1tor">&quot;&lt;=&quot; operátor</h2>
<p>Kissebb vagy egyenlő...</p>
<pre class="hljs"><code><div>if (2 &lt;= 5) {
    console.log(&quot;yes1&quot;);
}

if (2 &lt;= 2) {
    console.log(&quot;yes2&quot;);
}

if (2 &lt; 2) {
    console.log(&quot;yes3&quot;);
}

//Szintén nem fogjuk látni azt hogy &quot;yes3&quot;, mert 2 nem kissebb 2-nél, viszont azt hogy &quot;yes2&quot; látni fogjuk, mert 2 kissebb VAGY egyenlő 2-vel.
</div></code></pre>
<h1 id="logikai-oper%C3%A1torok">Logikai operátorok</h1>
<p>Mind tudjuk, pl egy <code>if ()</code> függvény akkor fog lefutni, amikor a zárójelbe &quot;true&quot; érték kerül. A felső operátorok is &quot;true&quot; vagy &quot;false&quot; értéket adnak vissza összehasonlításkor, viszont fontos még ismernünk a logikai operátorokat, hogy egyszerre több dolgot tudjunk összehasonlítani.</p>
<h2 id="%22%22-oper%C3%A1tor">&quot;&amp;&amp;&quot; operátor</h2>
<p>&quot;ÉS&quot; operátor, azaz a két oldalán levő dolgot nézi, és csak akkor &quot;true&quot; értéket, ha mindkét oldalon lévő dolog igaz.</p>
<pre class="hljs"><code><div>if (5 &gt; 2 &amp;&amp; 2 != 3) {
    console.log(&quot;yes&quot;);
}
</div></code></pre>
<p>Itt most láthatjuk hogy &quot;yes&quot;, mivel &quot;ÉS&quot; operátort használtunk arra, hogy 5 nagyobb mint 2 (true) és 2 nem egyenlő 3-al (true), azaz true és true az igaz, így lefut az &quot;if&quot; függvényünk.</p>
<h2 id="%22%22-oper%C3%A1tor">&quot;||&quot; operátor</h2>
<p>&quot;VAGY&quot; operátor, az akkor fog true-t adni, ha a két oldalán legalább az egyik dolog igaz.</p>
<pre class="hljs"><code><div>if (5 &gt; 2 || 2 == 3) {
    console.log(&quot;yes1&quot;);
}

if (5 &lt; 2 || 2 == 3) {
    console.log(&quot;yes2&quot;);
}
</div></code></pre>
<p>Láthatjuk azt a konzolba hogy &quot;yes1&quot; mivel az 5 nagyobb mint 2 (true), viszont a 2 nem egyenlő 3-al (false), de mivel &quot;VAGY&quot; logikai operátort használtunk, elég volt hogy a kettőből 1 legyen true, így lefutott az &quot;if&quot;-ünk. A másik esetnél viszont egyik vizsgálatunk se lett igaz, így nem láthatjuk hogy &quot;yes2&quot; mivel mindkét oldalon &quot;false&quot; értéket kaptunk, így nem lett &quot;true&quot; a &quot;VAGY&quot; logikai operátorunk, így nem futott le az az &quot;if&quot;.</p>
<h1 id="f%C3%BCggv%C3%A9nyek-%C3%A9s-funkci%C3%B3k">Függvények és funkciók</h1>
<h2 id="%22if%22-vizsg%C3%A1lat">&quot;if&quot; vizsgálat</h2>
<p>Már a nevéből is láthatjuk hogy &quot;HA&quot; függvény, ami akkor fog lefutni, &quot;HA&quot; valami igaz. Elnézést hogy előtte már csomószor használtam az &quot;if&quot; vizsgálatot és csak most beszélek róla, de midlife crysis-om lett attól hogy előtte magyarázzam el ezt vagy utánna... Hát most jó lesz így is.</p>
<pre class="hljs"><code><div>if (2 &gt; 1) {
    console.log(&quot;yes&quot;);
}
</div></code></pre>
<p>Mint láthatjuk kiírta a konzol azt hogy &quot;yes&quot;, mivel teljesült az &quot;if&quot; vizsgálat. Miért és hogyan? Az &quot;if ()&quot; vizsgálatunk úgy működik, hogy a zárójelbe &quot;true&quot; értéket vár el, hogy lefusson. Ugye most a példakódban egy vizsgálatot írtam bele, hogy 2 nagyobb-e mint 1, ami azt adja vissza hogy &quot;true&quot; így teljesül az &quot;if&quot; és a benne lévő kód lefut.</p>
<pre class="hljs"><code><div>if (2 &lt; 1) {
    console.log(&quot;yes&quot;);
} else {
    console.log(&quot;Hát nem&quot;);
}
</div></code></pre>
<p>A fenti példában azt láthatjuk, hogy hamis értéket adtam meg az &quot;if&quot;-ben, azaz 2 nem kissebb mint az 1, így &quot;false&quot; értéket kapott az &quot;if&quot;, így ami az &quot;if&quot;-ben van benne kód, nem futott le, viszont ha megnézed ott egy &quot;else&quot; ág, onnan kiírta hogy &quot;hát nem&quot;. Miért? Azért, mert ha &quot;if else&quot; függvényt írunk, akkor ha az &quot;if&quot;-ben beírt dolog nem teljesül, akkor az &quot;else&quot; ágban lévő kód fog lefutni.</p>
<pre class="hljs"><code><div>var number1 = 5;
var number2 = 3;

if (number1 &lt; number2) {
    console.log(&quot;number1 nem kissebb mint number2&quot;);
} else if (number1 == number2) {
    console.log(&quot;Hát nem egyenlő&quot;);
} else {
    console.log(&quot;egyik feltételnek se felelt meg&quot;);
}
</div></code></pre>
<p>Azt fogjuk látni hogy egyik feltétel se teljesült. Az &quot;if&quot;-et bolondíthatjuk még &quot;else if&quot; ággal is, hogy ha az első &quot;if&quot;-be nem felelne meg, utána írhatunk még további vizsgálatot, és ha az se felel meg, utána még egy else-t is írhatunk ha akarjuk, hogy mindenképpen történjen valami.</p>
<h2 id="%22switch%22-vizsg%C3%A1lat">&quot;switch&quot; vizsgálat</h2>
<p>Switch-case vizsgálatot akkor érdemes használni, amikor véletlenül írtunk egy ilyen &quot;if else if&quot; gányolmányt:</p>
<pre class="hljs"><code><div>var name = &quot;Jani&quot;;

if (name == &quot;Béla&quot;) {
    console.log(&quot;Ő Béla&quot;);
} else if (name == &quot;Jani&quot;) {
    console.log(&quot;Ő Jani&quot;);
} else if (name == &quot;Zoli&quot;) {
    console.log(&quot;Ő Zoli&quot;);
} else if (name == &quot;Árpád&quot;) {
    console.log(&quot;Ő Árpád&quot;);
} else if (name == &quot;Pisti&quot;) {
    console.log(&quot;Ő Pisti&quot;);
} else {
    console.log(&quot;fuj baszki&quot;);
}
</div></code></pre>
<p>.....na most hogy visszatértem miután kezet mostam ezután a borzalom megírása után, megmutatnám nektek, hogy ilyen esetekben miért használjunk inkább switch-case-t. A fenti undormányt átírom szép switch-case-be:</p>
<pre class="hljs"><code><div>var name = &quot;Jani&quot;;

switch (name) {
    case &quot;Béla&quot;:
        console.log(&quot;Ő Béla&quot;);
        break;
    case &quot;Jani&quot;:
        console.log(&quot;Ő Jani&quot;);
        break;
    case &quot;Zoli&quot;:
        console.log(&quot;Ő Zoli&quot;);
        break;
    case &quot;Árpád&quot;:
        console.log(&quot;Ő Árpád&quot;);
        break;
    case &quot;Pisti&quot;:
        console.log(&quot;Ő Pisti&quot;);
        break;
    default:
        console.log(&quot;na ez már nem fúj!&quot;);
}
</div></code></pre>
<p>Na most ha megpróbáljátok mindkettő kódot lefuttatni, ugyan azt a működést fogjátok tapasztalni, de ha megnézitek a kódot, ebben az esetben a switch-case mennyivel elegánsabb és átláthatóbb, nem?! Működése az, hogy a &quot;switch (variable)&quot; zárójelébe írjátok azt a változót, aminek az értékét akarjátok vizsgálni. A Switch-case olyan mintha minden megadott adattal &quot;==&quot; operátoros vizsgálatot végezne. A &quot;case&quot;-ekbe megtudjuk adni az értéket hogy mivel kell megfelelnie, ez lehet szöveg macskaköröm között, vagy csak simán szám hogy: <code>case 2:</code> és akkor a 2-es számot fogja vizsgálni. A legvégén a &quot;default:&quot; pedig olyan mint az &quot;if else&quot;-ben a sima &quot;else&quot; ág.</p>
<h2 id="%22for%22-ciklus">&quot;for&quot; ciklus</h2>
<p>A &quot;for&quot; ciklust arra szoktuk használni, ha valamilyen műveletet, egy adott mennyiségszer kell lefuttatni. Az alábbi példakódban azt láthatod, hogy 0-tól 99-ig, azaz 100szor lefut ez a kód, és ahol éppen jár, annak a számát kiírja a konzolba, egymás után.</p>
<pre class="hljs"><code><div>for (var i = 0; i &lt; 100; i++) {
    console.log(i);
}
</div></code></pre>
<p>A felépítése, a következő. Nézzük meg a &quot;for&quot; ciklus utáni zárójelet: <code>var i = 0;</code> ez a kezdőértékünk, létrehozunk egy változót, általában &quot;i&quot; szokott a neve lenni, de amúgy lehet bármi. Ez jelenleg 0-tól indul, onnan kezdi a számlálást. <code>i &lt; 100</code> ez pedig a feltétel, hogy meddig fut a ciklusunk, jelenleg megadtuk azt hogy amég &quot;i&quot; kissebb mint 100, addig fusson. Végül <code>i++</code>-t láthatunk a végén, itt pedig az történik, hogy amikor lefutott a ciklus, eggyel növeli az &quot;i&quot;-nek az értékét.</p>
<p>Ezután a &quot;for&quot; ciklusban láthatjuk azt, hogy én mindig kiiratom az aktuális értékét az &quot;i&quot; változónknak.</p>
<pre class="hljs"><code><div>for (var i = 0; i &lt; 100; i++) {
    if (i % 2 == 0) {
        console.log(i);
    }
}
</div></code></pre>
<p>Játszunk egy kicsit a benne lévő &quot;i&quot; változóval. A fenti kódban írtam egy olyat, hogy menjen végig 100szor a for ciklusunk, és minden páros számos irasson ki. Láthatjuk hogy a for ciklusba tettem egy &quot;if&quot; vizsgálatot, ahol a már beszélt &quot;%&quot; jeles operátorral megnézem hogy az adott számot elosztom kettővel, mennyi lesz a maradék. Ha 0 a maradék, akkor tudom hogy páros, szóval kiiratom a számot, ha nem 0, azaz páratlan szám lesz, akkor nem csinálok semmit.</p>
<h2 id="function">function</h2>
<p>JavaScript-ben a function-ök azaz a funkciók, végtelenül hasznos dolgok. Mivel ha mondjuk van egy kód halmazunk, ami csinál valamit, és sokszor szeretnénk használni, nem kell azt a kódot többször leírnunk a kódunkba, hanem elég betenni egy funkcióba, amit később meghívunk, esetleg még értéket is adunk neki.</p>
<pre class="hljs"><code><div>function kisCica() {
    console.log(&quot;Kiscica&quot;);
}

kisCica();
</div></code></pre>
<p>Ez a kód azt fogja csinálni, hogy csináltunk egy funkciót, aminek az a neve hogy &quot;kisCica&quot; (fontos hogy zárójelet írtunk utána, mivel így lesz egy funkció). Majd ebbe beleírtuk a kódunkat, amit leszeretnénk futtatni. és utána &quot;kisCica();&quot; kóddal meghívtuk a függvényünket.</p>
<p>Most a függvényünk csak csinál valamit, de tudunk olyat is, hogy visszaadjon valami értéket! Ezt így tudjuk megvalósítani:</p>
<pre class="hljs"><code><div>function kisCica() {
    console.log(&quot;Kiscica&quot;);
    return &quot;yes&quot;;
}

var something = kisCica();
console.log(something);
</div></code></pre>
<p>Na most elmagyarázom hogy mit csinál ez. A funkciónkban a &quot;return&quot; kulccsszó vissza ad valami értéket, jelen esetben egy szöveget, hogy &quot;yes&quot;. Ezt pedig én betöltöttem egy változóba. Szóval létrehoztam egy &quot;something&quot; változót, aminek az egyenlőség jel után a &quot;kisCica();&quot; függvényt meghívtam, ami vissza ad egy &quot;yes&quot; nevű értéket, na meg kiiratja a konzolba hogy &quot;Kiscica&quot;.</p>
<p>Most pedig csináljunk olyant is, hogy átadunk egy értéket a függvénynek, azzal csináljon valamit, és adja vissza! Csináljunk egy egyszerű szám összeadó függvényt:</p>
<pre class="hljs"><code><div>function sum(number1, number2) {
    var total = number1 + number2;
    return total;
}

var total_function = sum(2,3);
console.log(total_function);
</div></code></pre>
<p>A fenti funkciónkba azt csináltuk, hogy a &quot;sum()&quot; zárójelébe megadtunk két változót, amit később majd elvárunk amikor meghívjuk a funkciónkat. Jelen esetbe két változót adtam meg, amiknek az a neve hogy number1 és number2. Ezeket a változókat tudjuk később használni a funkciónkba. Én most azt csináltam itt, hogy a két számot összeadtam egy &quot;total&quot; változóba, majd ezt vissza return-öljük. Később pedig egy &quot;total_function&quot; nevű változóba meghívtam ezt a funkciót, ahol megadtam neki hogy a 2 meg 3 számot adja össze, és ugye mint fentebb is említettem, vissza ad egy értéket, jelen esetbe az összeadott két számot, ami 5 lesz, és ezt hogy lássuk, &quot;console.log&quot;-al kiírjuk.</p>
<h1 id="adatt%C3%ADpusok">Adattípusok</h1>
<p>Előzőleg már beszéltünk a számokról, és a szövegekről, nézzünk meg még két új dolgot.</p>
<h2 id="boolean">Boolean</h2>
<p>A boolean két értékű adattipus. Azaz vagy &quot;true&quot; vagy &quot;false&quot;. Ezek megfelelője lehet még az &quot;1&quot; és a &quot;0&quot;, mivel programozási nyelvekben az 1 az true-t jelent, a 0 false. De maradjunk a &quot;true&quot; és &quot;false&quot; értékeknél, mivel ezek a boolean-ok.</p>
<pre class="hljs"><code><div>var ezigaz = true;
var eznemigaz = false;

if (ezigaz) {
    console.log(&quot;igaz bizony.&quot;);
}
</div></code></pre>
<p>Ez kifogja írni hogy &quot;igaz bizony&quot; mivel az &quot;ezigaz&quot; változónak true az értéke, és ugye az if azt várja el.</p>
<p>Amikor egy vizsgálatot csinálunk, mint például:</p>
<pre class="hljs"><code><div>var valami = 3 &gt; 2;
console.log(valami);
</div></code></pre>
<p>akkor azt látjuk, hogy &quot;true&quot; lett a &quot;valami&quot; változó értéke, azért, mert megadtunk egy vizsgálatot neki hogy három nagyobb-e mint kettő, arra visszakapta azt hogy &quot;true&quot; és ez került a változóba.</p>
<h2 id="t%C3%B6mb">Tömb</h2>
<p>A tömb is egy adattípus, arra jó, hogy egy változóban egyszerre több adatot tároljunk el.</p>
<pre class="hljs"><code><div>var tomb = [&quot;Kiscica&quot;, &quot;Kiskutya&quot;, &quot;Bicikli&quot;];
</div></code></pre>
<p>Így hozunk létre egy tömböt, szögletes zárójellel, és vesszővel választjuk el benne az adatokat. Természetesen nem csak szöveg kerülhet bele, bármilyen adatot bele írhatunk. Szöveget, számot, booleant stb...</p>
<p>Hogyan tudunk adatot kiolvasni belőle? Hát értelem szerűen egyszerre csak egy dolgot akarunk kiolvasni belőle, azt így tudjuk megtenni:</p>
<pre class="hljs"><code><div>var tomb = [&quot;Kiscica&quot;, &quot;Kiskutya&quot;, &quot;Bicikli&quot;];
console.log(tomb[0]);
</div></code></pre>
<p>Ezzel a konzolba azt fogjuk látni hogy &quot;Kiscica&quot;. A <code>tomb[0]</code> változó megjelenítésével megjelenítettük a tömb első elemét. Azért 0, mert PHP-ban a számolást 0-tól kezdjük, azaz a tömbnek a 0.-ik eleme az első, az 1 a második és így tovább.</p>
<p>Hogyan tudjuk okosan kiiratni a tömb minden elemét? Nyilván nem akarjuk kézzel megirogatni hogy <code>tomb[0]; tomb[1];</code> stb... Használjuk az előzőleg tanult for ciklust!</p>
<pre class="hljs"><code><div>var tomb = [&quot;Kiscica&quot;, &quot;Kiskutya&quot;, &quot;Bicikli&quot;];

for (var i = 0; i &lt; tomb.length; i++) {
    console.log(tomb[i]);
}
</div></code></pre>
<p>Ha ezt lefuttatjuk, szépen sorban kiírja a tömb összes elemét. Hogyan működik ez? A for ciklusba megadtuk azt, hogy addig fusson amekkora a tömb mérete, ezt úgy adtuk meg hogy a <code>tomb.length</code> paranccsal megkaptunk számba hogy mennyi elem van a tömbbe, jelen esetbe ez 3, szóval 3szor fog lefutni a for ciklus. Utánna pedig ugye már tanultuk hogy a for ciklusban az <code>i</code> változó növekszik mindig, hogy éppen hol jár a ciklus. Szóval ahogy előbb írtam hogy <code>tomb[0]</code>-val jelenítem meg a tömb első elemét, ezt a számot kell növelni. Szóval logikusan beírjuk hogy <code>tomb[i]</code> így ahogy fut a for ciklus, mindig az aktuális elemet fogja kiírni.</p>

</body>
</html>
